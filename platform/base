#!/bin/bash
####################################################################
# PREY Base Functions - by Tomas Pollak (bootlog.org)
# URL: http://preyproject.com
# License: GPLv3
####################################################################

####################################################################
# base functions
####################################################################

# fetches a var and then assigns it as $value
# expects the name of hash and then the name of var
function get_var {
	HASH="$1[*]"
	local ${!HASH}
	eval 'echo ${'"${2}"'} | sed -e "s/%20/ /g"'
}

# if you need to fetch a specific trace or file
function get_trace {
	get_var traces ${current_module}__$1
}

function get_file {
	get_var files ${current_module}__$1
}

function add_trace {
	trace="${current_module}__$1=$2"
	echo " -- Adding trace for $current_module: $1 -> $2"
	# we need to encode whitespaces, otherwise well get into trouble
	trace=`echo $trace | sed 's/\s/%20/g'`
	traces[${#traces[*]}]="$trace"
}

function add_file {
	if [ -f "$2" ]; then
		echo " -- Adding file for $current_module: $1 -> $2"
		files[${#files[*]}]=${current_module}__$1=$2
	fi
}

function list_traces {
	# echo " -- ${#traces[*]} traces gathered!"
	for t in "${traces[@]}"
	do
		current_node=`echo $t | sed 's/^\([^_].*\)__\(.*\)$/\1/'`
		# if [ $current_node != $previous_node ]; then
			# echo $current_node
		# fi
		if [ "$post_method" == 'http' ]; then
			# echo -n $t | sed 's/^\([^_].*\)__\([^=].*\)=\(.*\)/\1[\2]="\3"\&/' # query string
			echo "-F $t" | sed 's/^\([^_].*\)__\([^=].*\)=\(.*\)/\1[\2]=\3/' # form field list
			# echo $t | sed 's/^\([^_].*\)__\([^=].*\)=\(.*\)$/<\2>\3<\/\2>/' # xml
		else
			# removes module name, then capitalizes, and replaces _'s with whitespaces
			echo -e "$t\n" | sed 's/^\([^_].*\)__//' | sed 's/^./\u&/' | sed 's/_/ /'
		fi
		# previous_node=$current_node
	done
}

function list_files {
	# echo " -- ${#files[*]} files gathered!"
	for f in "${files[@]}"
	do
		if [ "$post_method" == 'http' ]; then
			# echo -e "-F $f" | sed -e 's/=/=@/'
			echo "-F $f" | sed 's/^\([^_].*\)__\([^=].*\)=\(.*\)/\1[\2]=@\3/'
		else # just list the file paths
			echo -e $f | sed -e 's/.*=//'
		fi
	done
}

function remove_traces {
	unset -v traces
	echo ' -- Dropping all traces!'
}

function remove_files {
	for f in "${files[@]}"
	do
		file=`echo $f | sed -e 's/^.*=//'`
		rm -f $file
		echo " -- Removed $file"
	done
}

####################################################################
# string functions
####################################################################

# TODO: should switch to more advanced forms of encryption!
function encrypt {
	echo -n "$1" | openssl enc -base64
}

function decrypt {
	echo "$1" | openssl enc -base64 -d
}

###################################################################
# request/response functions
####################################################################

getter='curl -s'

# returns if we have have network access, otherwise 0
# you can check against the gateway or the net, change it if you like
function check_net_status {
	get_gateway_ip
	net_check_target=$gateway_ip
	# net_check_target="www.google.com"
	connected=`ping -q -c 1 $net_check_target &> /dev/null && echo 1 || echo 0`
}

# we could eventually use a different method for status checking
function check_status {
	if [ "$post_method" == 'http' ]; then
		check_url="$check_url/devices/$device_key.xml"
	fi
	headers=`$getter -I $check_url`
	status=`echo "$headers" | awk /HTTP/ | sed 's/[^200|302|400|404|500]//g' | sed 's/^0//'`
}

# we may eventually use a specific header for Prey
function parse_headers {
	content_type=`echo "$headers" | grep "Content-Type" | sed 's/.*: \([a-z\/-]*\).*/\1/'`
}

# this is where the magic will happen. :)
# some ideas:
	# if its a shell script, run it and post back the response
	# if its a zip file, unzip it in modules and run the active modules (the executable ones)
	# if its a xml/json file, parse it and assign config values correspondingly
function process_response {
	if [ "$content_type" == "application/xml" ]; then
		echo ' -- Got XML. Parsing...'
		response_type='xml'
	elif [ "$content_type" == "application/octet-stream" ]; then
		echo ' -- Got a ZIP file! What shall we do with it?'
		response_type='zip'
	elif [ "$content_type" == "text/plain" ]; then
		echo ' -- Got a text file! Lets see if its something we can actually run.'
		response_type='text'
	elif [ "$content_type" == "text/html" ]; then
		echo " -- Response was just an HTML file. Lets just do our job."
		return
	else
		return
	fi
	response=`$getter $check_url`
	eval 'process_'"${response_type}"''
}

# REALLY untested. function expects a <modules> section in the xml and activates de modules as requested
# format should be as follows:

# <device>
# 	<device-type>phone</device-type>
#		<missing>true</missing>
# </device>
# <configuration>
#		<delay>10</delay>
#		<loop>0</loop>
# </configuration>
#	<modules>
#		<module name="alert" active="true">
#			<alert-message>asdasd</alert-message>
#		</module>
#		<module name="autologin" active="true">
#			<user-name>guest</user-name>
#		</module>
#		<module name="report" active="false">
#			<traceroute>y</traceroute>
#		</module>
#	</modules>

# it should also work with one-line module entries (with no configuration), such as
#
# <module name="location" active="true" />

function process_xml {

	process_config
	process_modules

}

function process_config {

	echo -e "$response" | sed -n '/<configuration>/,/<\/configuration>/p'  | grep -v "configuration>" | while read line; do

		if [[ "$line" =~ 'delay' ]]; then
			delay=`echo $line | sed 's/^<.*>\([^<].*\)<.*>$/\1/'`
			if [ -n "$delay" ]; then
				echo " -- Setting delay to $delay minutes!"
				(crontab -l | grep -v prey; echo "*/$delay * * * * $base_path/prey.sh > /dev/null") | crontab -
			fi
		elif [[ "$line" =~ 'auto_update' && "$line" =~ "true" ]]; then
			auto_update="y"
			echo ' -- Auto update enabled!'
		fi

	done

}

function process_modules {

	echo -e "$response" | sed -n '/<modules>/,/<\/modules>/p' | grep -v "/module" | sed '1d' | while read line; do

	if [[ "$line" =~ 'name="' ]]; then # we have a module node
		module=`echo $line | sed 's/.*name="\([a-z_]*\)".*/\1/'`
		echo " -- Got instructions for $module module."
		if [[ "$line" =~ "true" ]]; then # module should be active
			if [ ! -d $base_path/modules/$module ]; then # not installed
				echo " -- Installing new $module module!"
				if [ `install_or_update_module $module` == 1 ]; then # we got an error installing the new module
					module=''
					continue
				fi
			elif [ "$auto_update" == "y" ]; then  # module is already installed and auto_update is enabled
				upstream_version=`echo $line | sed 's/^.*version="\([^"].*\)".*/\1/'`
				current_version=`cat $base_path/modules/$module/version 2> /dev/null`
				if [ $upstream_version -gt $current_version ]; then
				echo " -- Updating $module module!"
					install_or_update_module $module
					if [ `install_or_update_module $module` == 1 ]; then # we got an error installing the new module
						module=''
						continue
					fi
				fi
			fi
			if [ ! -x $base_path/modules/$module/run ]; then
				echo " -- Enabling $module module!"
				chmod +x $base_path/modules/$module/run
			fi
		else # module should be inactive
			if [ -x $base_path/modules/$module/run ]; then
				echo " -- Disabling $module module!"
				chmod -x $base_path/modules/$module/run
			fi
			module='' # this allows us to check below if the module is inactive
		fi
	else
		if [[ -n "$module" && -f $base_path/modules/$module/config ]]; then # module is active and has configuration
			param=`echo $line | sed 's/^<\(.*\)>.*<.*>$/\1/' | sed 'y/-/_/'` # we also replace -'s to _'s
			value=`echo $line | sed 's/^<.*>\([^<].*\)<.*>$/\1/'`
			echo " -- Updating setting $param -> $value for $module module."
			sed -i -e "s/$param=.*$/$param='$value'/" $base_path/modules/$module/config
		fi
	fi

	done

}

# this is REALLY untested stuff
# we should put this in a module with the new hash-by-module trace structure

function process_text {
	if [[ -n `echo $response | grep '#!/bin/bash'` && ! -n `echo $response | grep ' rm '` ]]; then
		echo ' -- Valid script! Lets get it on.'
		script=/tmp/script.sh
		echo -e $response > $script
		chmod +x $script
		output=`$script`
		add_trace 'script_output' $output
	else
		echo " !! Invalid script. Remember Prey doesn't run any external script which try to destroy things (for security reasons)."
	fi
}

function process_zip {
	echo ' -- Processing ZIP... (well, not really :)'
}

####################################################################
# module functions
####################################################################

function get_module {
	wget "$check_url/modules/get/$1?api_key=$api_key" -O /tmp/$1.zip &> /dev/null
}

# this should work, we only need to set up the module repository!
function install_or_update_module {
	get_module $1
	package_size=`cat /tmp/$1.zip 2> /dev/null | wc -c`
	if [ $package_size -gt 0 ]; then
		echo " -- Got new $1 module from repository! Unpackaging..."
		mv /tmp/$1.zip $base_path/modules
		if [ -d "$base_path/modules/$1" ]; then # module already installed
			# if [ -f "$base_path/modules/$1/config" ]; then # with configuration
			# 	echo ' -- Saving previous configuration values...'
			# 	cp $base_path/modules/$1/config /tmp/prey-module-$1-config.tmp
			# fi
			rm -R $base_path/modules/$1
		fi
		unzip $base_path/modules/$1.zip
		chmod +x $base_path/modules/$module/run # lets activate it in case its not
		rm $base_path/modules/$1.zip
		# if [ -f "/tmp/prey-module-$1-config.tmp" ]; then
		# 	echo ' -- Applying previous configuration values...'
		# 	mv /tmp/prey-module-$1-config.tmp $base_path/modules/$1/config
		# fi
		echo " -- New $1 module placed and ready to go!"
		return 0
	else
		echo " !! Couldn't get $1 module from repository."
		return 1
	fi
}

function run_active_modules {

	for module_path in `find $base_path/modules -maxdepth 1 -mindepth 1 -type d`; do

		if [ -x $module_path/run ]; then

			current_module=`echo "$module_path" | sed "s:$base_path\/modules\/::"`
			echo -e " -- Running $current_module module!"

			# if there's a language file, lets run it
			if [ -f $module_path/lang/$lang ]; then
			. $module_path/lang/$lang
			elif [ -f $module_path/lang/$lang ]; then
			. $module_path/lang/en
			fi

			# if there's a config file, lets run it as well
			if [ -f $module_path/config ]; then
				. $module_path/config
			fi

			# lets load the base functions for the module
			if [ -f $module_path/platform/base ]; then
				. $module_path/platform/base
			fi

			# and the OS-specific if there are
			if [ -f $module_path/platform/$os ]; then
				. $module_path/platform/$os
			fi

			# now, go!
			. $module_path/run
		fi

	done
	unset -v current_module

}

####################################################################
# data posting functions
####################################################################

function post_data {
	trace_list=`list_traces`
	file_list=`list_files`
	if [[ $trace_list || $file_list ]]; then
		if [ "$test_mode" == 1 ]; then
			echo ' >> This is where the data gets sent. Though not in test mode!'
		else
			trace_file=/tmp/prey_traces.tmp
			echo "$trace_list" > $trace_file
			eval 'send_via_'"${post_method}"''
			rm $trace_file
		fi
		remove_traces
		remove_files
	else
		echo " -- No data to send. We're done!"
	fi
}

function send_via_email {
	decoded_pass=`decrypt "$smtp_password"`
	complete_subject="$mail_subject @ `date +"%a, %e %Y %T %z"`"
	response=`$base_path/lib/sendEmail -f "$mail_from" -t "$mail_to" -u "$complete_subject" -s $smtp_server -a $file_list -o message-file=$trace_file tls=auto username=$smtp_username password=$decoded_pass`
	if [[ "$response" =~ "ERROR" ]]; then
		echo -e "$STRING_ERROR_EMAIL"
		echo -e "\n This is the complete error message: \n $response\n"
	fi
}

function send_via_http {
	post_url=`echo $check_url | sed 's/\.xml/\/reports/'`
	if [ -n "$post_url" ]; then
		if [ -n "$api_key" ]; then
			post_data="$file_list -F api_key=$api_key"
		fi
		response=`curl -s $trace_list $post_data "$post_url"`
		# echo $response
	else
		echo ' !! You need to set up a URL for the HTTP sending to work!'
	fi
}

function send_via_scp {
	if [[ -n "$scp_server" && -n "$scp_path" ]]; then
		echo -e " -- Uploading the stuff to $scp_path in $scp_server..."
		new_folder="prey_data_`echo $start_time | sed 'y/ :/_-/'`"
		ssh $scp_server mkdir $scp_path/$new_folder
		status=`scp $trace_file $file_list $scp_server:$scp_path/$new_folder`
	else
		echo ' !! You need to set up a server in order to send the report via SCP!'
	fi
}
