#!/bin/bash
####################################################################
# Prey Linux Specific Functions - by Tomas Pollak
# (c) 2010 Fork Ltd. (usefork.com) - Licensed under the GPLv3.
####################################################################

run_as_current_user(){
	if [ "`whoami`" != "$logged_user" ]; then
		DISPLAY=:0 sudo su $logged_user -c "$1"
	else
		eval $1
	fi
}

############################################
# network-specific functions
############################################

get_gateway_ip() {
	[ -z "$gateway_ip" ] && gateway_ip=$(ip r | grep default | cut -d ' ' -f 3)
}

get_wifi_device() {
	[ -z "$wifi_device" ] && wifi_device=$(iwconfig 2>&1 | grep -v "no wireless" | cut -f1 -d" " | grep -v "^$" | tail -1)
}

get_wifi_info() {
	[ -z "$wifi_info" ] && wifi_info=$(iwconfig 2>&1 | grep -v "no wireless")
}

# attempts to connect to the first open public wifi network
# if we dont have NetworkManager available, we use plain iwconfig
try_to_connect() {

	if [ -n "$(is_process_running $network_manager_process)" ]; then

		log " -- Restarting $network_manager_process and giving it some time to connect."
		service $network_manager_process restart &> /dev/null
		sleep 5

	else

		get_wifi_device
		if [ -n "$wifi_device" ]; then

			# access_points=`iwlist $wifi_device | awk -F '[ :=]+' '/(ESS|Freq|Qual)/{ printf $3" " } /Encr/{ print $4 }' | sort -k4 -k3nr`
			local open_essid=`\`which iwlist\` $wifi_device scan | awk -F '[ :=]+' '/(ESS|Freq|Qual)/{ printf $3" " } /Encr/{ print $4 }' | sort -k4 -k3nr | grep "off" | head -1 | cut -d ' ' -f1 | sed 's/"//g'`

			if [ -n $open_essid ]; then
				log " -- SSID found! Attempting to connect to ${open_essid}..."
				`which iwconfig` $wifi_device essid $open_essid
				`which dhclient3` $wifi_device
			else
				log ' -- No open SSIDs found.'
			fi

		else

			log ' !! No wifi device found!'

		fi

	fi

}

reverse_tunnel_command(){
	setsid "$base_path/lib/tunnel.sh" ${remote_tunnel_host} ${local_tunnel_port} ${remote_tunnel_port} ${remote_tunnel_user} ${remote_tunnel_pass} &> /dev/null
}

############################################
# trigger enabling functions
############################################

# echoes 1 if prey trigger is set
is_trigger_loaded(){
	find /etc/rc3.d/ | grep 'prey-trigger' > /dev/null && echo 1
}

reload_trigger(){
	log " -- Setting up network detection trigger init script..."
	linux_load_service 'prey-trigger'
}

# unloads trigger from launchd and removes plist file
unload_trigger(){
	log " -- Removing network detection trigger init script..."
	linux_unload_service 'prey-trigger'
}

############################################
# updater-specific functions
############################################

# here we'll eventually put whatever we need to do in linux before
# performing a full update
pre_update_hook(){
	return 0
}

# post update hooks go in here
post_update_hook(){
	log ' -- Reloading Prey...'
	"$base_path/prey.sh" & # lets restart prey now
}

############################################
# device creation stuff
############################################

get_pc_info(){
	pc_name=$(hostname)

	$(which laptop-detect)
	if [ $? == 1 ]; then
		pc_type="Desktop"
	else
		pc_type="Laptop"
	fi

	get_distro_name
	if [ "$distro_name" == "ubuntu" ]; then
		pc_os_version=$(lsb_release -r | sed 's/.*\t//g')
	elif [ "$distro_name" == "debian" ]; then
		pc_os_version=$(cat /etc/debian_version)
	fi

}

get_distro_name(){

	[ -n "$distro_name" ] && return 1

	local proc_version=$(cat /proc/version 2>&1)

	# todo: make this in a more efficient way
	if [ -n `find_in $distro 'Ubuntu'` ]; then
		distro_name=ubuntu
	elif [ -n `find_in $distro 'Debian'` ]; then
		distro_name=debian
	elif [ -n `find_in $distro 'Redhat'` ]; then
		distro_name=redhat
	elif [ -n `find_in $distro 'Fedora'` ]; then
		distro_name=fedora
	elif [ -n `find_in $distro 'CentOS'` ]; then
		distro_name=redhat
	elif [ -n `find_in $distro 'SuSE'` ]; then
		distro_name=suse
	elif [ -n `find_in $distro 'ArchLinux'` ]; then
		distro_name=arch
	else
		distro_name=linux
	fi

}

############################################
# distro-specific functions
############################################

linux_load_service(){
	get_distro_name
	eval "${distro_name}_load_service $1"
}

linux_unload_service(){
	get_distro_name
	eval "${distro_name}_unload_service $1"
}

linux_copy_init_script(){
	local full_init_script_path="$1/$2"
	if [ ! -e "$full_init_script_path" ]; then
		ln -s "$(full_path $base_path)/${platform_path}/${2}" "$full_init_script_path" 2> /dev/null
		local retval=$?
		[ $retval != 0 ] && log " !! Couldn't copy init script into ${1}!"
		return $retval
	fi
	return 0
}

linux_remove_init_script(){
	rm -f "$1/$2"
	return $?
}

debian_load_service(){
	linux_copy_init_script '/etc/init.d' $1
	[ $? == 0 ] && update-rc.d $1 defaults > /dev/null
}

alias ubuntu_load_service='debian_load_service'

# we need to delete the init script first so that update-rc.d remove works
# otherwise we'd need to use the -f argument
debian_unload_service(){
	linux_remove_init_script '/etc/init.d' $1
	[ $? == 0 ] && update-rc.d $1 remove > /dev/null
}

alias ubuntu_unload_service='debian_unload_service'

redhat_load_service(){
	linux_copy_init_script '/etc/rc.d/init.d' $1
	[ $? == 0 ] && chkconfig $1 on
}

alias fedora_load_service='redhat_load_service'

redhat_unload_service(){
	linux_remove_init_script '/etc/rc.d/init.d' $1
	[ $? == 0 ] && chkconfig $1 off
}

alias fedora_unload_service='redhat_unload_service'
